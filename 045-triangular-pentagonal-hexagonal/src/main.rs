// Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:
//
// Triangle	 	n=n(n+1)/2   1, 3, 6, 10, 15, ...
// Pentagonal	 n=n(3n - 1)/2   1, 5, 12, 22, 35, ...
// Hexagonal	 n=n(2n - 1)   1, 6, 15, 28, 45, ...
//
// It can be verified that   T(285) = P(165) = H(143) = 40755
// .
//
// Find the next triangle number that is also pentagonal and hexagonal.

use num_bigint::BigInt;
use std::time::Instant;

// Should I instead have one function that takes a closur of the algorithm?
fn get_triangular() -> impl Iterator<Item = BigInt> {
    (num_iter::range_from(BigInt::from(0u64)))
        .map(|n| &n * (&n + BigInt::from(1_u32)) / BigInt::from(2_u32))
}

fn get_pentagonal() -> impl Iterator<Item = BigInt> {
    (num_iter::range_from(BigInt::from(0u64)))
        .map(|n| &n * (BigInt::from(3_u32) * &n - BigInt::from(1_u32)) / BigInt::from(2_u32))
}

fn get_hexagonal() -> impl Iterator<Item = BigInt> {
    (num_iter::range_from(BigInt::from(0u64)))
        .map(|n| &n * (BigInt::from(2_u32) * &n - BigInt::from(1_u32)))
}

fn main() {
    let start = Instant::now();

    let mut h_iter = get_hexagonal();
    let mut p_iter = get_pentagonal();
    let mut t_iter = get_triangular();
    let mut h = h_iter.next().unwrap();
    let mut p = p_iter.next().unwrap();
    let mut t = t_iter.next().unwrap();

    loop {
        if h == p && h == t {
            println!("Found one: {}", h);
            if h > BigInt::from(40755_u32) {
                break;
            }
        }

        if h <= t {
            h = h_iter.next().unwrap();
        } else if p <= t {
            p = p_iter.next().unwrap();
        } else {
            t = t_iter.next().unwrap();
        }
    }

    println!("Time elapsed: {}", start.elapsed().as_secs_f64());
}
