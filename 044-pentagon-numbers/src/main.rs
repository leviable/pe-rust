// Pentagonal numbers are generated by the formula, pn = n(3n -1)/2. The first
// ten pentagonal numbers are: 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
//
// It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference,
// 70 - 22 = 48, is not pentagonal.
//
// Find the pair of pentagonal numbers, Pj and Pk, for which their sum and
// difference are pentagonal and D = |Pk - Pj | is minimised; what is the value of D?
//
// After doing some handwritten math, seems like the difference between Pk + Pj and the
// next highest Pentagonal number will reach a steady state with a consistent difference.
// Going to assume that if I hit the same difference 3 times in a row I can move on.

use std::time::Instant;

fn is_pentagonal(num: i32) -> bool {
    for n in 1.. {
        let sol = n * (3 * n - 1) / 2;
        if sol == num {
            return true;
        } else if sol > num {
            break;
        }
    }
    false
}

#[test]
fn test_is_pentagonal() {
    for num in vec![1, 5, 12, 22, 35, 51, 70, 92, 117, 145] {
        assert!(is_pentagonal(num));
    }

    for num in vec![2, 6, 13, 24, 36, 52, 71, 93, 118, 146] {
        assert!(!is_pentagonal(num));
    }
}

fn pe044() -> usize {
    for j in (2..).map(|n| n * (3 * n - 1) / 2).take(100000) {
        for k in (2..).map(|n| n * (3 * n - 1) / 2).take(100000) {
            if is_pentagonal(j + k) {
                // println!("Found a sum pentagonal: {j} + {k} = {}", j + k);
                if is_pentagonal((k - j).abs()) {
                    println!("Found a minus pentagonal: {j} + {k} = {}", (j + k).abs());
                }
            } else {
            }
        }
    }
    0
}

fn main() {
    let start = Instant::now();
    let solution = pe044();
    println!("The solution is: {solution}");
    println!("Time elapsed: {}", start.elapsed().as_secs_f64());
}
