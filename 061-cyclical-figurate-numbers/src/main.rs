use std::error::Error;

// Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
//
// Triangle 	 	P3,n = n(n+1)/2     -> 1, 3, 6,  10, 15...
// Square       	p4,n = n**2         -> 1, 4, 9,  16, 25...
// Pentagonal	 	p5,n = n(3*n-1)/2   -> 1, 5, 12, 22, 35...
// Hexagonal        p6,n = n(n2-1)      -> 1, 6, 15, 28, 45...
// Heptagonal       p7,n = n(5n-3)/2    -> 1, 7, 18, 34, 55...
// Octagonal        p8,n = n(3*n-2)     -> 1, 8, 21, 40, 65...
//
// The ordered set of three 4-digit numbers: 8128,2882,8381 , has three
// interesting properties.
//
// 1. The set is cyclic, in that the last two digits of each number is the first two
//    digits of the next number (including the last number with the first).
// 2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and
//    pentagonal (P4,55=2882), is represented by a different number in the set.
// 3. This is the only set of 4-digit numbers with this property.
//
// Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
//
enum polygonal {
    Triangle,
    Square,
    Pentagonal,
    Hexagonal,
    Heptagonal,
    Octagonal,
}

impl polygonal {
    fn new(num: u64) -> Result<Self, std::error::Error> {
        if polygonal::is_triangle(num) {
            Ok(Self.Triangle)
        } else if polygonal::is_square(num) {
            Ok(Self.Square)
        } else if polygonal::is_pentagonal(num) {
            Ok(Self.Pentagonal)
        } else if polygonal::is_hexagonal(num) {
            Ok(Self.Hexagonal)
        } else if polygonal::is_heptagonal(num) {
            Ok(Self.Heptagonal)
        } else if polygonal::is_octagonal(num) {
            Ok(Self.Octagonal)
        } else {
            Error("Not figurate")
        }
    }

    fn is_triangle(num: u64) -> bool {
        let val = (num * (num + 1) / 2) as f64;
        val.floor() == val.ceil()
    }

    fn is_square(num: u64) -> bool {
        let val = (num * num + 1) / 2) as f64;
        val.floor() == val.ceil()
    }

    fn is_triangle(num: u64) -> bool {
        let val = (num * (num + 1) / 2) as f64;
        val.floor() == val.ceil()
    }

    fn is_triangle(num: u64) -> bool {
        let val = (num * (num + 1) / 2) as f64;
        val.floor() == val.ceil()
    }

    fn is_triangle(num: u64) -> bool {
        let val = (num * (num + 1) / 2) as f64;
        val.floor() == val.ceil()
    }

    fn is_triangle(num: u64) -> bool {
        let val = (num * (num + 1) / 2) as f64;
        val.floor() == val.ceil()
    }
}

fn main() {
    let start = std::time::Instant::now();
    println!("Time elapsed: {}", start.elapsed().as_secs_f64());
}
